<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>WebGL入门-Part3</title>
      <link href="/2018/08/21/WebGL%E5%85%A5%E9%97%A8-3/"/>
      <url>/2018/08/21/WebGL%E5%85%A5%E9%97%A8-3/</url>
      <content type="html"><![CDATA[<p><a href="https://blog.normaldev.app/2018/08/18/WebGL%E5%85%A5%E9%97%A8-2/" target="_blank" rel="noopener">Part2</a>中 写了个简单的着色器在画布中绘制了一个点，接下来 通过向着色器传递参数的形式去绘制，同时利用缓冲区一次传递多个参数。</p><p>有两种方式能够用来传递参数：<strong>attribute变量</strong> 和 <strong>uniform变量</strong>.</p><p>attribute用来传输与顶点相关的数据，uniform则与之相反，传递的是通用的数据（与顶点无关的）。</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>在着色器中声明attribute和uniform变量后， 可以通过JavaScript传递给着色器。</p><p>声明变量的格式：<strong>「存储限定符」「类型」「变量名」 </strong></p><p>顶点着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 aPosition; <span class="comment">// 通过attribute 声明变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">gl_Position = aPosition;</span><br><span class="line">    gl_PointSize = <span class="number">10.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片元着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">precision mediump <span class="keyword">float</span>; <span class="comment">// 精度限定符</span></span><br><span class="line">uniform vec4 uColor; <span class="comment">// 通过 uniform 声明变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">gl_FragColor = uColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取变量地址"><a href="#获取变量地址" class="headerlink" title="获取变量地址"></a>获取变量地址</h2><p>向WebGL获取某个变量的地址、JS通过给这个地址赋值从而将值传递给着色器。</p><h3 id="获取attribute变量"><a href="#获取attribute变量" class="headerlink" title="获取attribute变量"></a>获取attribute变量</h3><p>getAttribLocation方法接收两个参数：</p><ul><li>gl.program是WebGL的program对象，只有在初始化（通过 的工具方法<code>initShaders()</code>）后才能获取到。</li><li>第二个参数是变量名，也就是你在着色器中定义的变量名称。</li></ul><p>Return：</p><ul><li>✅成功正确获取的地址为 &gt;= 0 的值。</li><li>❌获取失败返回结果为<strong>-1</strong></li></ul><p><code>const aPosition = gl.getAttribLocation(gl.program, &#39;aPosition&#39;);</code></p><h3 id="获取uniform变量"><a href="#获取uniform变量" class="headerlink" title="获取uniform变量"></a>获取uniform变量</h3><p>getUniformLocation方法同getAttribLocation方法一样，接收两个参数。</p><p>Return：</p><ul><li>✅非null值；表示获取成功</li><li>❌null值；表示获取失败</li></ul><p><code>const uColor = gl.getUniformLocation(gl.program, &#39;uColor&#39;);</code></p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p> 分别拿到了变量的地址，然后就可以向着色器传递参数。</p><h3 id="向attribute传参"><a href="#向attribute传参" class="headerlink" title="向attribute传参"></a>向attribute传参</h3><p><code>gl.vertexAttrib[1234]f()</code>向attribute传递参数，这是一个系列函数，[1234]分别对应四个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> gl.vertexAttrib1f(location, v0);</span><br><span class="line"><span class="keyword">void</span> gl.vertexAttrib2f(location, v0, v1);</span><br><span class="line"><span class="keyword">void</span> gl.vertexAttrib3f(location, v0, v1, v2);</span><br><span class="line"><span class="keyword">void</span> gl.vertexAttrib4f(location, v0, v1, v2, v3);</span><br></pre></td></tr></table></figure><p>第一个参数为上一步所获取到的着色器变量的地址，后面为需要传递的值。</p><p><code>gl.vertexAttrib4f(aPosition, 0.0, 0.5, 0.0, 0.0);</code> 向aPosition传递一个位于(0.0, 0.5, 0.0, 0.0)的点。</p><h3 id="向uniform传参"><a href="#向uniform传参" class="headerlink" title="向uniform传参"></a>向uniform传参</h3><p><code>gl.uniform[1234]f</code>向uniform传参，同样这也是一个系列函数。</p><p>接收的参数也和<code>vertexAttrib</code>方法一样。</p><p><code>gl.uniform4f(uColor, 1.0, 0.0, 0.0, 0.0);</code> 向片元着色器传递一个红颜色。</p><p>💡<a href="https://jsbin.com/fivuxixipi/edit?html,js,output" target="_blank" rel="noopener">传递参数给着色器_DEMO</a></p><h2 id="Buffer缓冲区传递参数"><a href="#Buffer缓冲区传递参数" class="headerlink" title="Buffer缓冲区传递参数"></a>Buffer缓冲区传递参数</h2><p>在上面的例子中， 只是笨拙的向着色器传递单个参数，当 需要一次根据多个Position进行绘制时就需要一次传递多个参数给着色器。</p><p>接下来 通过缓冲区向着色器传递多个参数。</p><h3 id="创建缓冲区对象"><a href="#创建缓冲区对象" class="headerlink" title="创建缓冲区对象"></a>创建缓冲区对象</h3><p><code>gl.createBuffer()</code>创建缓冲区对象</p><p><code>gl.deleteBuffer(buffer)</code>可以用来删除已有的缓冲区对象</p><h3 id="绑定缓冲区"><a href="#绑定缓冲区" class="headerlink" title="绑定缓冲区"></a>绑定缓冲区</h3><p><code>gl.bindBuffer(target, buffer)</code>  将创建的缓冲区对象buffer绑定到目标区域。</p><p>target参数可以是下面其中之一：</p><ul><li>gl.ARRAY_BUFFER ——表示缓冲区对象中包含顶点的数据</li><li>gl.ELEMENT_ARRAY_BUFFER —— 表示缓冲区对象包含了顶点的索引值</li></ul><h3 id="写入数据到缓冲区"><a href="#写入数据到缓冲区" class="headerlink" title="写入数据到缓冲区"></a>写入数据到缓冲区</h3><p>因为数据不能直接写入缓冲区，所以需要通过上一步，将缓冲区和Target进行绑定，接下来通过<code>gl.bufferData(target, vertices, usage)</code>将数据写入『目标』。</p><h4 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h4><p>有一种特殊的数组，其中的元素都是同一种类型， 称之为类型化数组。</p><p>有下面几种类型</p><ul><li>Int[8|16|32]Array —— [8|16|32]位整型数组</li><li>UInt[8|16|32]Array —— [8|16|32]位无符号整型数组</li><li>Float[32|64]Array —— 单、双精度[32|64]位浮点数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">0.5</span>,</span><br><span class="line">    <span class="number">-0.5</span>, <span class="number">-0.5</span>,</span><br><span class="line">    <span class="number">0.5</span>, <span class="number">-0.5</span>,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>定义写入缓冲区的数据</p><h4 id="USAGE"><a href="#USAGE" class="headerlink" title="USAGE"></a>USAGE</h4><p>usage表示程序如何使用存储在缓冲区对象中的数据，可以帮助WebGL优化操作，就算传错了也不会异常，仅仅可能降低了运行效率。</p><p>有以下三个取值：</p><ul><li>gl.STATIC_DRAW ——向缓冲区对象写入一次数据，但需要绘制很多次</li><li>gl.STREAM_DRAW ——向缓冲区对象写入一次数据，绘制若干次</li><li>gl.DYNAMIC_DRAW ——写入多次数据、绘制很多次</li></ul><p>了解这些 就可以通过<code>gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)</code>将数据写入缓冲区对象。</p><h3 id="分配缓冲区对象给attribute"><a href="#分配缓冲区对象给attribute" class="headerlink" title="分配缓冲区对象给attribute"></a>分配缓冲区对象给attribute</h3><p>前面 通过系列函数给attribute和uniform传递参数，这些方法一次只能传递一个值</p><p><code>gl.vertexAttribPointer(location, size, type, normalize, stride, offset)</code>可以将整个缓冲区对象分配给attribute。</p><ul><li>location —— 前面获取到的attribute的地址</li><li>size —— 表示每个顶点的所需要的的分量个数</li><li>tyle —— 指定数据格式</li><li>normalize —— true or false，表示是否将非浮点数的数据规划到[0, 1] 或者 [-1 ,1]</li><li>stride —— 相邻结点间的字符数</li><li>offset —— 数据的偏移量</li></ul><p>有几个参数还是挺抽象的，看个🌰</p><p>假设需要通过一个buffer，分配給两个不同的attribute， 可以这样操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个Array分别描述点的位置和颜色 </span></span><br><span class="line"><span class="keyword">const</span> muitVertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="comment">// 描述点描述颜色</span></span><br><span class="line">    <span class="number">0.0</span>, <span class="number">-0.5</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.1</span>,</span><br><span class="line">    <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.1</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> FSIZE = muitVertices.BYTES_PER_ELEMENT;</span><br><span class="line"><span class="comment">// 写入缓冲区</span></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="comment">// 分配缓冲区对象給位置attribute  aPosition</span></span><br><span class="line"><span class="comment">// stride为5可以理解为每5个元素为一组数据</span></span><br><span class="line"><span class="comment">// size为2，offset为0 意味着aPosition 需要用到 一组数据（就是5个元素）中的前两个</span></span><br><span class="line">gl.vertexAttribPointer(aPositionLocation, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">5</span> * FSIZE, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 分配缓冲区对象給颜色attribute aColor</span></span><br><span class="line"><span class="comment">// size为3，offset为2 意味着aColor 需要用到 一组数据（就是5个元素）中去掉前两个(偏移量)的后三个</span></span><br><span class="line">gl.vertexAttribPointer(aColorLocation, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">5</span> * FSIZE, <span class="number">2</span> * FSIZE);</span><br></pre></td></tr></table></figure><h3 id="开启attribute对象"><a href="#开启attribute对象" class="headerlink" title="开启attribute对象"></a>开启attribute对象</h3><p>为了能够让着色器访问缓冲区内的数据， 需要使用<code>gl.enableVertexAttribArray(location)</code>来开启对应的attribute对象。</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>接着 就可以通过<code>gl.drawArrays(type, start, count)</code>来绘制了，此时 还能通过改变第二、三个参数来绘制不同的形状了。</p><p>第一个参数是绘制的类型，<a href="https://blog.normaldev.app/2018/08/18/WebGL%E5%85%A5%E9%97%A8-2/" target="_blank" rel="noopener">Part-2</a>中有讲到 ，可以自行尝试更改。</p><p>start表示从第几个attribute开始绘制</p><p>count表示从start开始绘制几个点</p><p>⚠️ start + count &lt;= 总数</p><p>💡<a href="https://jsbin.com/gegatifawa/edit?html,js,output" target="_blank" rel="noopener">DEMO</a></p>]]></content>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebGL入门-Part2</title>
      <link href="/2018/08/18/WebGL%E5%85%A5%E9%97%A8-2/"/>
      <url>/2018/08/18/WebGL%E5%85%A5%E9%97%A8-2/</url>
      <content type="html"><![CDATA[<p><a href="https://blog.normaldev.app/2018/08/17/WebGl%E5%85%A5%E9%97%A8-1/" target="_blank" rel="noopener">WebGL入门-Part1</a> 中介绍了一些基本概念，接着我们来用WebGL画点东西，熟悉绘制WebGL的基本流程。</p><h2 id="获取上下文环境"><a href="#获取上下文环境" class="headerlink" title="获取上下文环境"></a>获取上下文环境</h2><p>WebGL的绘制也是在<code>&lt;canvas&gt;</code>标签的基础上进行绘制的，第一步也是创建CanvasDom并获取其WebGL的上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#J_canvas'</span>);</span><br><span class="line"><span class="comment">// 在不同浏览器环境下</span></span><br><span class="line"><span class="comment">// context可能对应着不同的值 ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"]</span></span><br><span class="line"><span class="keyword">const</span> gl = canvas.getContext(<span class="string">'webgl'</span>);</span><br></pre></td></tr></table></figure><h2 id="定义着色器"><a href="#定义着色器" class="headerlink" title="定义着色器"></a>定义着色器</h2><p>WebGL必须要使用着色器进行绘制，我们要用 GLSL ES 定义顶点着色器和片元着色器。</p><p>我们先定义分别定义顶点、片元着色器，绘制一个点。</p><p>着色器语言1均表示的最高值，-1就是最小值。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>每个着色器都有一个main函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  gl_Position = vec4(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 描述点的位置</span></span><br><span class="line">  gl_PointSize = <span class="number">10.0</span>; <span class="comment">// 点的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vec4(R, G, B, A) 1就表示R的值为最高也就相当于颜色RGBA(255, 0, 0, 1);</span></span><br><span class="line">    gl_FragColor = vec4(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 点的颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化着色器"><a href="#初始化着色器" class="headerlink" title="初始化着色器"></a>初始化着色器</h2><p>这里我们先使用辅助函数<code>initShaders(gl, vshader, fshader)</code>初始化着色器，后面我们会详细讲解其内部实现。</p><h2 id="清空绘制区域"><a href="#清空绘制区域" class="headerlink" title="清空绘制区域"></a>清空绘制区域</h2><p>在绘制之前我们可以先清空绘制区域</p><p><code>gl.clearColor(0.0, 1.0, 0.0, 0.5);</code>设置清空背景的填充色</p><p><code>gl.clear(buffer);</code> 执行清空</p><p>buffer指的是缓冲区，执行清空其实就是将指定缓冲区设为给定的值。</p><p>取值有以下三种类型</p><ul><li>gl.COLOR_BUFFER_BIT  颜色缓冲区</li><li>gl.DEPTH_BUFFER_BIT 深度缓冲区</li><li>gl.STENCIL_BUFFER_BIT 模板缓冲区</li></ul><p>通过<code>gl.clear(gl.COLOR_BUFFER_BIT)</code>将颜色缓冲区设为我们给定的色值。</p><p><code>gl.clear(buffer | buffer)</code>可以指定多个缓冲区.</p><p>💡如果清空的颜色不变，则没有必要重复设置clearColor。</p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>通过<code>drawArrays(mode, first, count)</code>进行绘制。</p><p>first - 表示从哪个定带你开始绘制</p><p>count - 表示要此次绘制需要用到多少个顶点</p><p>mode告诉WebGL以哪种方式进行绘制，有以下几种方式，可以分别尝试一下。</p><p>🤷‍♂️不过，我们目前只有一个顶点，除了Point其他也画不了。 </p><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fudrhjys1rj212e0lugtc.jpg" alt="绘制方式"></p><p>通过<code>gl.drawArrays(glCtx.POINTS, 0, 1);</code>绘制一个点.</p><p>⚠️drawArrays绘制后会清空缓冲区，上一步clear背景色变成默认的透明，如果还需要背景色，需要再一次<code>gl.clear();</code></p><p>💡<a href="https://jsbin.com/vasepolexu/2/edit?html,js,output" target="_blank" rel="noopener">这里是DEMO</a></p><p>试着改变着色器中的各个参数会发生什么吧。</p><p><a href="https://blog.normaldev.app/2018/08/18/WebGL%E5%85%A5%E9%97%A8-3/" target="_blank" rel="noopener">To Be Continue ✍️ 向着色器传递参数 &gt;&gt;&gt;</a></p>]]></content>
      
      
        <tags>
            
            <tag> WebGl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebGL入门-Part1</title>
      <link href="/2018/08/17/WebGl%E5%85%A5%E9%97%A8-1/"/>
      <url>/2018/08/17/WebGl%E5%85%A5%E9%97%A8-1/</url>
      <content type="html"><![CDATA[<blockquote><p>WebGL是一项用来在网页上绘制和渲染复杂三维图形(3D图形)，并允许用户与之进行交互的技术。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在个人计算机上使用最广泛的两种三维图形渲染技术是微软的Direct3D和OpenGL。</p><p>WebGL技术规范继承自免费和开源的OpenGL标准，某种意义上，WebGL就是<br>“Web版的OpenGL”。</p><p>OpenGL、OpenGL ES各版本和WebGL的关系 </p><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fud2af28yej20w80b248i.jpg" alt="OpenGL、OpenGL ES各版本和WebGL的关系"></p><p>WebGL不仅仅包含Javascript还需要引入着色器语言 GLSL ES。</p><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fud2grgii2j20u20ca47v.jpg" alt="页面结构对比"></p><p>通过阅读《WebGL编程指南》进行入门是一个不错的选择。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在用WebGL绘制第一个图形前呢，先简单的了解一些概念，方便我们后面对代码的理解。</p><h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><p>使用WebGL绘图就必须使用着色器，在代码中着色器是以字符串形式「嵌入」在JavaScript中的，在这其中需要用到两种着色器，着色器使用<strong><code>GLSL ES</code></strong>语言编写，有点类似于C语言。</p><ul><li><p>顶点着色器</p><p>顾名思义，用来描述顶点特性的程序。举个栗子，顶点可以是二维图形或三维图形的端点或交点，三角形的三个就属于顶点。</p></li><li><p>片元着色器</p><p>对逐个片元进行一一处理的程序，定义如何处理WebGL程序的每一个片元，可以把片元理解为像素。片元着色器可以进行一些牛B的特效处理、比如光照之类的。</p></li></ul><h3 id="WebGL坐标系"><a href="#WebGL坐标系" class="headerlink" title="WebGL坐标系"></a>WebGL坐标系</h3><p>WebGL使用的是三维坐标系，X（水平正方向向右）、Y（垂直，正方向向上）、Z（垂直于屏幕，正方向冲向外，也就是和观察者视线相反）轴。</p><p>也被称为右手坐标系，然鹅实际上并不是，现在就这么认为把。</p><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fud31ukxqhj20mo0k6djs.jpg" alt="坐标系"></p><h3 id="Canvas和WebGL坐标系的对应关系"><a href="#Canvas和WebGL坐标系的对应关系" class="headerlink" title="Canvas和WebGL坐标系的对应关系"></a>Canvas和WebGL坐标系的对应关系</h3><p>WebGL的绘制也是基于Canvas绘制的嘛，三维坐标和二维坐标之间也存在一个对应的关系。</p><p>坐标的最大为1、最小为-1；原点位于中心位置。</p><ul><li>Canvas中心点：(0.0, 0.0, 0.0);</li></ul><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fud368984tj20he0d8aes.jpg" alt="Canvas和WebGL坐标对应关系"></p><h3 id="Canvas与WebGL坐标的相互转换"><a href="#Canvas与WebGL坐标的相互转换" class="headerlink" title="Canvas与WebGL坐标的相互转换"></a>Canvas与WebGL坐标的相互转换</h3><p>假设鼠标在Canvas上点哪里就要在对应位置绘制内容，可以这样去转换坐标。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">canvas.addEventListener(<span class="string">'mousedown'</span>, (evt) =&gt; &#123;</span><br><span class="line">  <span class="comment">// rect 是一个具有四个属性left、top、right、bottom的DOMRect对象</span></span><br><span class="line">  <span class="comment">// 除了width和 height、四个坐标均是DOM边界相对于视窗左上角</span></span><br><span class="line">  <span class="keyword">const</span> rect = evt.target.getBoundingClientRect();</span><br><span class="line">  <span class="comment">// 原点位于中心，宽高分别除2</span></span><br><span class="line">  <span class="keyword">const</span> height = canvas.height / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> width = canvas.width / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> x = ((evt.clientX - rect.left) - width) / width;</span><br><span class="line">  <span class="keyword">const</span> y = (height - (evt.clientY - rect.top)) / height;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在了解这些基本概念后，我们就可以着手使用WebGL绘制一些内容啦。</p><p><a href="https://blog.normaldev.app/2018/08/18/WebGL%E5%85%A5%E9%97%A8-2/" target="_blank" rel="noopener">To Be Continue ✍️绘制一个点&gt;&gt;&gt;</a></p>]]></content>
      
      
        <tags>
            
            <tag> WebGl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PD虚拟机搭建CentOS-7环境</title>
      <link href="/2018/07/07/PD%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BACentOS-7%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/07/07/PD%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BACentOS-7%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>第一次接触CentOS之类的内容，以前大学时Linux的课也没好好听过（捂脸），搞得一头雾水。<br>SSH直接操作VPS延迟挺大的不爽，于是就利用虚拟机创建个环境方便自己学习。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>Parallels Desktop (Windows对应VM或者其他的虚拟机就可以)</li><li><a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso" target="_blank" rel="noopener">CentOS-7-x86_64-Minimal镜像</a></li></ol><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>我用的是PD13.3，可能不同版本之间部分细节会有差异。<br>安装很简单，新建 =&gt; 选择下载的CentOS =&gt; 勾选快速安装(省事)，这里设置的密码会成为root用户的密码。<br>这里的网络方式我选择了<strong>共享网络</strong>，在后续的操作中并没有出现不通的情况。</p><p>然后就是等待重启，并输入用户名root和刚才设置的密码，成功登录就ok。</p><h2 id="SSH访问虚拟机"><a href="#SSH访问虚拟机" class="headerlink" title="SSH访问虚拟机"></a>SSH访问虚拟机</h2><p>在虚拟机里直接操作太麻烦，且用户体验不好，我们使用SSH访问虚拟机并一顿操作。</p><ol><li><p>检查<code>openssh-server</code><br><code>yum list installed | grep openssh-server</code> 检查是否已经安装，如果没有则需要通过yum来安装<br><code>yum install openssh-server</code></p></li><li><p>配置ssh_config<br>在<code>/etc/ssh/sshd_config</code>有ssh服务的配置，用vim对其编辑<br><code>vi /etc/ssh/sshd_config</code></p><p>对配置做如下更改<br>开启端口号<br>将Port、ListenAddress、ListenAddress 的注释放开、删除前面的#<br><img src="http://pbh6tbqw4.bkt.clouddn.com/image/open_SSH_Config_1.png" alt="配置修改1"><br>接着在不远的后面，将PasswordAuthentication设为ye’s，虽然好像本来就是yes，如果有注释也要放开<br><img src="http://pbh6tbqw4.bkt.clouddn.com/image/open_SSH_Config_2.png" alt="配置修改2"></p></li><li><p>开启sshd<br><code>sudo service sshd start</code>开启服务<br><code>ps -e | grep sshd</code>检查sshd服务开启情况</p></li><li><p>测试是否互通<br>CentOS中输入<code>ifconfig</code>查看虚拟机的CentOS具体ip<br>没有<code>ifconfig</code>命令可以通过<code>yum install net-tools</code>安装<br><img src="http://pbh6tbqw4.bkt.clouddn.com/image/ifconfig.png" alt="ifconfig"><br>虚拟机中通过<code>ping 主机ip</code>测试能否ping通<br>反过来主机通过<code>ping 虚拟机ip</code>测试<br>均能ping通基本没问题，可以通过SSH访问虚拟机了，如果ping不通请Google一下，我没遇到~</p></li></ol><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>我们通过IUS源来安装各种包<br><code>sudo yum install https://centos7.iuscommunity.org/ius-release.rpm</code></p><p>通过yum 安装 Nginx<code>yum install nginx</code></p><p>开机启动Nginx <code>sudo systemctl start nginx.service</code></p><p>然后发现主机访问不了虚拟机的Nginx服务，但的的确确是通的。<br>其实是CentOS的防火墙搞的鬼，我们设置一下。</p><p><code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code></p><p> –zone 表示 作用于<br> –add-port 为添加端口/协议<br> –permanent 永久生效，不加的话重启就凉了</p><p>重启防火墙<br><code>systemctl stop firewalld.service</code><br><code>systemctl start firewalld.service</code><br>如此一来也就可以愉快的访问虚拟机的Nginx服务了</p><h2 id="安装uWSGI"><a href="#安装uWSGI" class="headerlink" title="安装uWSGI"></a>安装uWSGI</h2><p><code>pip install uwsgi</code></p><p>如果报错的话检查下<code>python3-devel</code>是否有安装<br>通过<code>yum -y install python36u-devel</code> 进行安装</p><h3 id="uWSGI放在Nginx后遇到的错误"><a href="#uWSGI放在Nginx后遇到的错误" class="headerlink" title="uWSGI放在Nginx后遇到的错误"></a>uWSGI放在Nginx后遇到的错误</h3><h4 id="failed-13-Permission-denied-while-connecting-to-upstream"><a href="#failed-13-Permission-denied-while-connecting-to-upstream" class="headerlink" title="failed (13: Permission denied) while connecting to upstream"></a>failed (13: Permission denied) while connecting to upstream</h4><p>Nginx转发请求本地接口时么有权限导致的</p><p><a href="https://stackoverflow.com/questions/21820444/nginx-error-13-permission-denied-while-connecting-to-upstream" target="_blank" rel="noopener">nginx-error-13-permission-denied-while-connecting-to-upstream</a></p><p>除了权限以外还有可能是Selinux<br><code>setsebool -P httpd_can_network_connect 1</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/trackle400/article/details/52755571" target="_blank" rel="noopener">虚拟机下CentOS7开启SSH连接</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>CentOs7_通过RPM安装Python3</title>
      <link href="/2018/06/24/CentOs7%E4%B8%8B%E9%80%9A%E8%BF%87RPM%E5%AE%89%E8%A3%85Python3/"/>
      <url>/2018/06/24/CentOs7%E4%B8%8B%E9%80%9A%E8%BF%87RPM%E5%AE%89%E8%A3%85Python3/</url>
      <content type="html"><![CDATA[<ol><li><p>安装IUS社区软件源<br><code>yum -y install https://centos7.iuscommunity.org/ius-release.rpm</code></p></li><li><p>安装</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  yum makecache</span><br><span class="line">➜  yum install python36u</span><br><span class="line">➜  yum -y install python36u-pip</span><br><span class="line">➜  yum -y install python36u-devel</span><br></pre></td></tr></table></figure><ol start="3"><li>更改shell命令</li></ol><p><code>sudo ln -s /bin/python3.6 /bin/python3</code><br><code>sudo ln -s /bin/pip3.6 /bin/pip3</code></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Webpack注入内联样式及脚本</title>
      <link href="/2018/06/24/Webpack%E6%B3%A8%E5%85%A5%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E5%8F%8A%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/06/24/Webpack%E6%B3%A8%E5%85%A5%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E5%8F%8A%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>一般情况下，利用Webpack打包项目会生成一个HTML文件和一个script入口文件。<br>在分chunk的时候也会为各个chunk生成不同的script文件，并注入到HTML文件中。</p><p>然而因为业务上的需求，有时会一些很简单的活动页面，利用Webpack打包一个HTML单文件，扔到服务器上就能用，简单粗暴，更新的时候也只要更新一个文件就可以，不必将脚本、样式和HTML分别更新。</p><h2 id="html-webpack-inline-source"><a href="#html-webpack-inline-source" class="headerlink" title="html-webpack-inline-source"></a>html-webpack-inline-source</h2><p><a href="https://www.npmjs.com/package/html-webpack-inline-source-plugin" target="_blank" rel="noopener">html-webpack-inline-source-plugin</a>和HtmlWebpackPlugin插件配合，可以将打包生成的文件注入为行内样式和行内脚本。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>通过npm安装html-webpack-inline-source<br><code>npm install --save-dev html-webpack-inline-source-plugin</code></p><p>在Webpack的plugins中进行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackInlineSourcePlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-inline-source-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Webpack config</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(),</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackInlineSourcePlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>ennnnn其实上面上面这样配置插件不会做任何事情去注入行内脚本和样式, 需要在HtmlWebpackPlugin中告诉它哪些东西需要注入行内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        inlineSource: <span class="string">'.(js|css)$'</span> <span class="comment">// embed all javascript and css inline</span></span><br><span class="line">    &#125;),</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackInlineSourcePlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样在我们最后build的时候index.html中就会包含行内样式和脚本。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>微信H5获取iBeacons设备信息</title>
      <link href="/2018/06/05/%E5%BE%AE%E4%BF%A1H5%E8%8E%B7%E5%8F%96iBeacons%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/06/05/%E5%BE%AE%E4%BF%A1H5%E8%8E%B7%E5%8F%96iBeacons%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol><li>公众号申请开通摇一摇周边</li><li>添加设备并激活对应设备</li><li>拿到设备的一系列参数</li></ol><p>设备信息类似于：<br>请将下表的UUID、Major、Minor信息配置至iBeacon设备，其中，major、minor为10进制。</p><table><thead><tr><th>部署设备</th><th>设备ID</th><th>UUID</th><th>major值</th><th>minor值</th></tr></thead><tbody><tr><td>设备zero</td><td>3214551</td><td>FDA15795-A3E2-4FB1-DEWF-C6EB07154725</td><td>10100</td><td>44511</td></tr></tbody></table><p>1、2是前提条件，不满足API不会有任何反应<br>3 是后续会用到的参数，让PM弄好了给你，如果你自己就是PM就在公众号里找找，可以导出对应Excel</p><h2 id="获取beacon信息"><a href="#获取beacon信息" class="headerlink" title="获取beacon信息"></a>获取beacon信息</h2><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1443448133" target="_blank" rel="noopener">H5页面获取设备信息 JS API</a></p><p>微信提供了开启、监听、关闭三个Beacon对应的接口。<br>在开始查找之前还需要将设备添加至对应分组，否则<code>onSearchBeacons</code>不会有任何反应、不进入任何回调</p><h3 id="添加beacon至分组"><a href="#添加beacon至分组" class="headerlink" title="添加beacon至分组"></a>添加beacon至分组</h3><p>根据文档-(新增分组)[<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1459330208]" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1459330208]</a> </p><p>然后将步骤3中的设备加到分组中，<code>onSearchBeacons</code>只能监听位于分组中的beacon设备</p><h3 id="监听beacons"><a href="#监听beacons" class="headerlink" title="监听beacons"></a>监听beacons</h3><p>监听周边beacon前需要执行<code>startSearchBeacons</code>开启查找beacon</p><p>接着在成功回调中执行<code>onSearchBeacons</code>监听周围的beacon设备</p><h4 id="没反应的原因"><a href="#没反应的原因" class="headerlink" title="没反应的原因"></a>没反应的原因</h4><p>在开发过程中遇到的没有反应的原因有以下几种</p><ol><li>设备不在分组中</li><li>公众号没有添加设备</li><li>对应beacon设备没有绑定当前页面的URL</li><li>注册微信SDK的公众号和添加设备的公众号不一致</li></ol><h2 id="关闭beacon搜索"><a href="#关闭beacon搜索" class="headerlink" title="关闭beacon搜索"></a>关闭beacon搜索</h2><p>开启<code>startSearchBeacons</code>后，微信中关闭网页并不会自动stopSearchBeacons。<br>只能手动执行<code>stopSearchBeacons</code>关闭，可添加<code>beforeunload</code> listener在页面卸载前手动关闭</p>]]></content>
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信H5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS_7部署Nginx服务</title>
      <link href="/2018/06/03/CentOS-7%E9%83%A8%E7%BD%B2Nginx%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/06/03/CentOS-7%E9%83%A8%E7%BD%B2Nginx%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>没完整的建过站，于是把闲置的搬瓦工用起来。</p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>用终端连接VPS<br><code>ssh root@ip_address -p port</code><br>换成对应的ip地址和端口，输入正确密码后就成功连接。</p><p><code>yum install nginx</code> 安装nginx失败，提示：没有可用软件包 nginx</p><p>源里没有那就直接从官网下好了</p><p><code>rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></p><p>再安装就成功了。</p><h2 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h2><p><code>systemctl start nginx</code></p><p>如果启动成功就可以通过直接访问IP地址看到喜闻乐见的 <strong>Welcome to nginx!</strong></p><h2 id="OpenSSL生成CSR文件申请SSL证书"><a href="#OpenSSL生成CSR文件申请SSL证书" class="headerlink" title="OpenSSL生成CSR文件申请SSL证书"></a>OpenSSL生成CSR文件申请SSL证书</h2><p>DogDaddy上注册了一个<code>.app</code>的域名，还送了一年证书，也正好用起来。</p><p><code>openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout myprivate.key -out mydomain.csr</code></p><p>new: 生成一个新的CSR<br>nodes: 私钥文件不被加密<br>sha256: 摘要算法<br>keyout: 生成私钥,<br>newkey rsa:2048: 指定私钥类型和长<br>mydomain.csr: 最后生成的文件名</p><p>执行上面命令后会要求输入以下内容</p><table><thead><tr><th>内容</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Country Name</td><td>国家代码</td><td>CN</td></tr><tr><td>State or Province Name</td><td>省份</td><td>Beijing</td></tr><tr><td>Locality Name</td><td>城市</td><td>Beijing</td></tr><tr><td>Organization Name</td><td>组织名称</td><td></td></tr><tr><td>Organization Unit Name</td><td>部门名称</td><td>IT</td></tr><tr><td>Common Name</td><td>证书申请域名</td><td>example.app</td></tr><tr><td>A challenge password</td><td>某个密码</td><td>可不填</td></tr><tr><td>Email Address</td><td>邮件</td><td>我没填</td></tr></tbody></table><p>最后在命令所在目录会生成一个<code>myprivate.key</code> 和一个 <code>mydomain.csr</code>，分别为私钥和CSR申请文件。</p><p>🐶爹添加证书的时候就把CSR文件里的内容拷进去，申请一下就等着邮件通知签发证书。</p><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p><a href="https://www.secureserver.net/help/article/27192?prog_id=504762" target="_blank" rel="noopener">NGINX on CentOS 7: Install a Certificate</a></p><h3 id="通过scp拷贝文件至vps"><a href="#通过scp拷贝文件至vps" class="headerlink" title="通过scp拷贝文件至vps"></a>通过scp拷贝文件至vps</h3><p>基本格式为：scp -P [端口号] [源文件路径] root@ip_address:[目标路径]</p><p><strong>-P一定要大写！</strong> 默认端口可省略 -P [端口号]</p><h3 id="乌龙"><a href="#乌龙" class="headerlink" title="乌龙"></a>乌龙</h3><p>因为我注册了个<code>.app</code>后缀的域名，证书下载下来是<code>domain.app</code>被Mac识别成APP了，要显示包内容才能看到里面两个<code>.crt</code>文件。</p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@host /]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure><p><code>/etc/nginx/nginx.conf</code>就是配置文件所在的目录</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">            <span class="string">server_name</span> <span class="string">coolexample.com;</span></span><br><span class="line">            <span class="string">return</span> <span class="number">301</span> <span class="attr">https://$host$request_uri;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">443</span> <span class="string">ssl;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">server_name</span> <span class="string">coolexample.com;</span></span><br><span class="line">        <span class="string">ssl_certificate</span>     <span class="string">/etc/nginx/ssl/coolexample.crt;</span></span><br><span class="line">        <span class="string">ssl_certificate_key</span> <span class="string">/etc/nginx/ssl/coolexample.key;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">root</span> <span class="string">/usr/share/nginx/coolexample.com/;</span></span><br><span class="line">        <span class="string">index</span> <span class="string">index.php</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在配置文件中加入对应的配置~</p><p><code>root</code>是对应站点的跟目录，起初没写。导致使用https访问会404</p><p><code>sudo service nginx restart</code>重启服务后应该可以生效了，如果重启失败可以通过<code>nginx -t</code>检查配置文件是否有问题</p><p>愉悦~</p>]]></content>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Echarts动态加载GeoJSON地图</title>
      <link href="/2018/06/02/Echarts%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDGeoJSON/"/>
      <url>/2018/06/02/Echarts%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDGeoJSON/</url>
      <content type="html"><![CDATA[<h2 id="Echarts监听GEO地图缩放比例"><a href="#Echarts监听GEO地图缩放比例" class="headerlink" title="Echarts监听GEO地图缩放比例"></a>Echarts监听GEO地图缩放比例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myChart.on(<span class="string">'georoam'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  console.log(arguments);</span></span><br><span class="line">    <span class="comment">// 回调函数自带的res中zoom永远都是1.1</span></span><br><span class="line">    <span class="built_in">console</span>.log(myChart.getOption().geo[<span class="number">0</span>].zoom);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="按需加载GEOJSON"><a href="#按需加载GEOJSON" class="headerlink" title="按需加载GEOJSON"></a>按需加载GEOJSON</h2><p>某个需求要求的是点亮用户去过的地方，国内到城市、国外精确到州。</p><p>在Echarts官方仓库中找到<a href="https://github.com/pissang/starbucks" target="_blank" rel="noopener"><strong>starbucks</strong></a>，内含各个州的GEO数据。</p><p>直觉告诉我只要拼起来就能实现word数据中包含所有州的信息。</p><h3 id="GEOJSON"><a href="#GEOJSON" class="headerlink" title="GEOJSON"></a>GEOJSON</h3><p><a href="https://www.oschina.net/translate/geojson-spec?lang=chs&amp;page=1#" target="_blank" rel="noopener">格式规范说明</a></p><p><img src="https://i.loli.net/2018/05/30/5b0e443bb5e1e.png" alt="carbon.png"></p><p>大致就是这样一个结构、具体的键值含义规范中有说明。<code>features</code>数组中的每一个对象都描述的是<strong>一块区域</strong>。那么把<code>world.json</code>里缺失的更细颗粒度的区域也加进来就ojbk了。</p><h3 id="多余的key"><a href="#多余的key" class="headerlink" title="多余的key"></a>多余的key</h3><p>上面结构多了<code>UTF8Encoding</code> <code>encodeOffsets</code> <code>name</code> 这几个key，在格式规范中不是必须的，看了下<code>Echarts</code>处理JSON部分的源码是有用到的，用于decode JSON文件。</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>起初直接将两个JSON对象的<code>features</code>进行合并<code>world.features.concat(china.features)</code></p><p>失败了，合出来的JSON虽然符合规范，但是并不正确，渲染出来严重畸形。</p><p><img src="https://i.loli.net/2018/05/30/5b0e47c808ca9.png" alt="什么鬼(#`O′)"></p><p>经过对比，<code>world.json</code>中的<code>coordinates</code>字段为经纬度，<code>china.json</code>中则为Encode处理后的经纬度。</p><p>Debug源码发现由<code>UTF8Encoding</code>控制是否对JSON内容进行Decode，于是给合并后的JSON数据加上<code>UTF8Encoding = true</code>，然后又失败了。</p><p>控制台抛出异常：<code>Invalid geoJson format; coordinate.charCodeAt is not a function</code></p><p>喵喵喵??  decode完就格式就不对了…<br>Debug源码找到原因，<code>UTF8Encoding</code>为true开启decode后，对整个list进行decode操作，decode操作又要用到<code>encodeOffsets</code>，<code>world.json</code>没有这个key，所以就嗝屁了。</p><p>在拼接JSON前先把JSON给decode好，不就没问题了么，试了一下果然搞定了。</p><h3 id="看个效果"><a href="#看个效果" class="headerlink" title="看个效果"></a>看个效果</h3><p><img src="https://i.loli.net/2018/06/02/5b122a8887373.gif" alt="Jun-02-2018 13-25-09.gif"></p>]]></content>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
