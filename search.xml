<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>WebGL入门-Part1</title>
      <link href="/2018/08/17/WebGl%E5%85%A5%E9%97%A8-1/"/>
      <url>/2018/08/17/WebGl%E5%85%A5%E9%97%A8-1/</url>
      <content type="html"><![CDATA[<blockquote><p>WebGL是一项用来在网页上绘制和渲染复杂三维图形(3D图形)，并允许用户与之进行交互的技术。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在个人计算机上使用最广泛的两种三维图形渲染技术是微软的Direct3D和OpenGL。</p><p>WebGL技术规范继承自免费和开源的OpenGL标准，某种意义上，WebGL就是<br>“Web版的OpenGL”。</p><p>OpenGL、OpenGL ES各版本和WebGL的关系 </p><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fud2af28yej20w80b248i.jpg" alt="OpenGL、OpenGL ES各版本和WebGL的关系"></p><p>WebGL不仅仅包含Javascript还需要引入着色器语言 GLSL ES。</p><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fud2grgii2j20u20ca47v.jpg" alt="页面结构对比"></p><p>通过阅读《WebGL编程指南》进行入门是一个不错的选择。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在用WebGL绘制第一个图形前呢，先简单的了解一些概念，方便我们后面对代码的理解。</p><h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><p>使用WebGL绘图就必须使用着色器，在代码中着色器是以字符串形式「嵌入」在JavaScript中的，在这其中需要用到两种着色器，着色器使用<strong><code>GLSL ES</code></strong>语言编写，有点类似于C语言。</p><ul><li><p>顶点着色器</p><p>顾名思义，用来描述顶点特性的程序。举个栗子，顶点可以是二维图形或三维图形的端点或交点，三角形的三个就属于顶点。</p></li><li><p>片元着色器</p><p>对逐个片元进行一一处理的程序，定义如何处理WebGL程序的每一个片元，可以把片元理解为像素。片元着色器可以进行一些牛B的特效处理、比如光照之类的。</p></li></ul><h3 id="WebGL坐标系"><a href="#WebGL坐标系" class="headerlink" title="WebGL坐标系"></a>WebGL坐标系</h3><p>WebGL使用的是三维坐标系，X（水平正方向向右）、Y（垂直，正方向向上）、Z（垂直于屏幕，正方向冲向外，也就是和观察者视线相反）轴。</p><p>也被称为右手坐标系，然鹅实际上并不是，现在就这么认为把。</p><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fud31ukxqhj20mo0k6djs.jpg" alt="坐标系"></p><h3 id="Canvas和WebGL坐标系的对应关系"><a href="#Canvas和WebGL坐标系的对应关系" class="headerlink" title="Canvas和WebGL坐标系的对应关系"></a>Canvas和WebGL坐标系的对应关系</h3><p>WebGL的绘制也是基于Canvas绘制的嘛，三维坐标和二维坐标之间也存在一个对应的关系。</p><p>坐标的最大为1、最小为-1；原点位于中心位置。</p><ul><li>Canvas中心点：(0.0, 0.0, 0.0);</li></ul><p><img src="https://ws1.sinaimg.cn/large/e908d83ely1fud368984tj20he0d8aes.jpg" alt="Canvas和WebGL坐标对应关系"></p><h3 id="Canvas与WebGL坐标的相互转换"><a href="#Canvas与WebGL坐标的相互转换" class="headerlink" title="Canvas与WebGL坐标的相互转换"></a>Canvas与WebGL坐标的相互转换</h3><p>假设鼠标在Canvas上点哪里就要在对应位置绘制内容，可以这样去转换坐标。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">canvas.addEventListener(<span class="string">'mousedown'</span>, (evt) =&gt; &#123;</span><br><span class="line">  <span class="comment">// rect 是一个具有四个属性left、top、right、bottom的DOMRect对象</span></span><br><span class="line">  <span class="comment">// 除了width和 height、四个坐标均是DOM边界相对于视窗左上角</span></span><br><span class="line">  <span class="keyword">const</span> rect = evt.target.getBoundingClientRect();</span><br><span class="line">  <span class="comment">// 原点位于中心，宽高分别除2</span></span><br><span class="line">  <span class="keyword">const</span> height = canvas.height / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> width = canvas.width / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> x = ((evt.clientX - rect.left) - width) / width;</span><br><span class="line">  <span class="keyword">const</span> y = (height - (evt.clientY - rect.top)) / height;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在了解这些基本概念后，我们就可以着手使用WebGL绘制一些内容啦。</p><p>To Be Continue &gt;&gt;&gt;</p>]]></content>
      
      
        <tags>
            
            <tag> WebGl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PD虚拟机搭建CentOS-7环境</title>
      <link href="/2018/07/07/PD%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BACentOS-7%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/07/07/PD%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BACentOS-7%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>第一次接触CentOS之类的内容，以前大学时Linux的课也没好好听过（捂脸），搞得一头雾水。<br>SSH直接操作VPS延迟挺大的不爽，于是就利用虚拟机创建个环境方便自己学习。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>Parallels Desktop (Windows对应VM或者其他的虚拟机就可以)</li><li><a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso" target="_blank" rel="noopener">CentOS-7-x86_64-Minimal镜像</a></li></ol><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>我用的是PD13.3，可能不同版本之间部分细节会有差异。<br>安装很简单，新建 =&gt; 选择下载的CentOS =&gt; 勾选快速安装(省事)，这里设置的密码会成为root用户的密码。<br>这里的网络方式我选择了<strong>共享网络</strong>，在后续的操作中并没有出现不通的情况。</p><p>然后就是等待重启，并输入用户名root和刚才设置的密码，成功登录就ok。</p><h2 id="SSH访问虚拟机"><a href="#SSH访问虚拟机" class="headerlink" title="SSH访问虚拟机"></a>SSH访问虚拟机</h2><p>在虚拟机里直接操作太麻烦，且用户体验不好，我们使用SSH访问虚拟机并一顿操作。</p><ol><li><p>检查<code>openssh-server</code><br><code>yum list installed | grep openssh-server</code> 检查是否已经安装，如果没有则需要通过yum来安装<br><code>yum install openssh-server</code></p></li><li><p>配置ssh_config<br>在<code>/etc/ssh/sshd_config</code>有ssh服务的配置，用vim对其编辑<br><code>vi /etc/ssh/sshd_config</code></p><p>对配置做如下更改<br>开启端口号<br>将Port、ListenAddress、ListenAddress 的注释放开、删除前面的#<br><img src="http://pbh6tbqw4.bkt.clouddn.com/image/open_SSH_Config_1.png" alt="配置修改1"><br>接着在不远的后面，将PasswordAuthentication设为ye’s，虽然好像本来就是yes，如果有注释也要放开<br><img src="http://pbh6tbqw4.bkt.clouddn.com/image/open_SSH_Config_2.png" alt="配置修改2"></p></li><li><p>开启sshd<br><code>sudo service sshd start</code>开启服务<br><code>ps -e | grep sshd</code>检查sshd服务开启情况</p></li><li><p>测试是否互通<br>CentOS中输入<code>ifconfig</code>查看虚拟机的CentOS具体ip<br>没有<code>ifconfig</code>命令可以通过<code>yum install net-tools</code>安装<br><img src="http://pbh6tbqw4.bkt.clouddn.com/image/ifconfig.png" alt="ifconfig"><br>虚拟机中通过<code>ping 主机ip</code>测试能否ping通<br>反过来主机通过<code>ping 虚拟机ip</code>测试<br>均能ping通基本没问题，可以通过SSH访问虚拟机了，如果ping不通请Google一下，我没遇到~</p></li></ol><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>我们通过IUS源来安装各种包<br><code>sudo yum install https://centos7.iuscommunity.org/ius-release.rpm</code></p><p>通过yum 安装 Nginx<code>yum install nginx</code></p><p>开机启动Nginx <code>sudo systemctl start nginx.service</code></p><p>然后发现主机访问不了虚拟机的Nginx服务，但的的确确是通的。<br>其实是CentOS的防火墙搞的鬼，我们设置一下。</p><p><code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code></p><p> –zone 表示 作用于<br> –add-port 为添加端口/协议<br> –permanent 永久生效，不加的话重启就凉了</p><p>重启防火墙<br><code>systemctl stop firewalld.service</code><br><code>systemctl start firewalld.service</code><br>如此一来也就可以愉快的访问虚拟机的Nginx服务了</p><h2 id="安装uWSGI"><a href="#安装uWSGI" class="headerlink" title="安装uWSGI"></a>安装uWSGI</h2><p><code>pip install uwsgi</code></p><p>如果报错的话检查下<code>python3-devel</code>是否有安装<br>通过<code>yum -y install python36u-devel</code> 进行安装</p><h3 id="uWSGI放在Nginx后遇到的错误"><a href="#uWSGI放在Nginx后遇到的错误" class="headerlink" title="uWSGI放在Nginx后遇到的错误"></a>uWSGI放在Nginx后遇到的错误</h3><h4 id="failed-13-Permission-denied-while-connecting-to-upstream"><a href="#failed-13-Permission-denied-while-connecting-to-upstream" class="headerlink" title="failed (13: Permission denied) while connecting to upstream"></a>failed (13: Permission denied) while connecting to upstream</h4><p>Nginx转发请求本地接口时么有权限导致的</p><p><a href="https://stackoverflow.com/questions/21820444/nginx-error-13-permission-denied-while-connecting-to-upstream" target="_blank" rel="noopener">nginx-error-13-permission-denied-while-connecting-to-upstream</a></p><p>除了权限以外还有可能是Selinux<br><code>setsebool -P httpd_can_network_connect 1</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/trackle400/article/details/52755571" target="_blank" rel="noopener">虚拟机下CentOS7开启SSH连接</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>CentOs7_通过RPM安装Python3</title>
      <link href="/2018/06/24/CentOs7%E4%B8%8B%E9%80%9A%E8%BF%87RPM%E5%AE%89%E8%A3%85Python3/"/>
      <url>/2018/06/24/CentOs7%E4%B8%8B%E9%80%9A%E8%BF%87RPM%E5%AE%89%E8%A3%85Python3/</url>
      <content type="html"><![CDATA[<ol><li><p>安装IUS社区软件源<br><code>yum -y install https://centos7.iuscommunity.org/ius-release.rpm</code></p></li><li><p>安装</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  yum makecache</span><br><span class="line">➜  yum install python36u</span><br><span class="line">➜  yum -y install python36u-pip</span><br><span class="line">➜  yum -y install python36u-devel</span><br></pre></td></tr></table></figure><ol start="3"><li>更改shell命令</li></ol><p><code>sudo ln -s /bin/python3.6 /bin/python3</code><br><code>sudo ln -s /bin/pip3.6 /bin/pip3</code></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Webpack注入内联样式及脚本</title>
      <link href="/2018/06/24/Webpack%E6%B3%A8%E5%85%A5%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E5%8F%8A%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/06/24/Webpack%E6%B3%A8%E5%85%A5%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E5%8F%8A%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>一般情况下，利用Webpack打包项目会生成一个HTML文件和一个script入口文件。<br>在分chunk的时候也会为各个chunk生成不同的script文件，并注入到HTML文件中。</p><p>然而因为业务上的需求，有时会一些很简单的活动页面，利用Webpack打包一个HTML单文件，扔到服务器上就能用，简单粗暴，更新的时候也只要更新一个文件就可以，不必将脚本、样式和HTML分别更新。</p><h2 id="html-webpack-inline-source"><a href="#html-webpack-inline-source" class="headerlink" title="html-webpack-inline-source"></a>html-webpack-inline-source</h2><p><a href="https://www.npmjs.com/package/html-webpack-inline-source-plugin" target="_blank" rel="noopener">html-webpack-inline-source-plugin</a>和HtmlWebpackPlugin插件配合，可以将打包生成的文件注入为行内样式和行内脚本。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>通过npm安装html-webpack-inline-source<br><code>npm install --save-dev html-webpack-inline-source-plugin</code></p><p>在Webpack的plugins中进行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackInlineSourcePlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-inline-source-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Webpack config</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(),</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackInlineSourcePlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>ennnnn其实上面上面这样配置插件不会做任何事情去注入行内脚本和样式, 需要在HtmlWebpackPlugin中告诉它哪些东西需要注入行内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        inlineSource: <span class="string">'.(js|css)$'</span> <span class="comment">// embed all javascript and css inline</span></span><br><span class="line">    &#125;),</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackInlineSourcePlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样在我们最后build的时候index.html中就会包含行内样式和脚本。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>微信H5获取iBeacons设备信息</title>
      <link href="/2018/06/05/%E5%BE%AE%E4%BF%A1H5%E8%8E%B7%E5%8F%96iBeacons%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/06/05/%E5%BE%AE%E4%BF%A1H5%E8%8E%B7%E5%8F%96iBeacons%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol><li>公众号申请开通摇一摇周边</li><li>添加设备并激活对应设备</li><li>拿到设备的一系列参数</li></ol><p>设备信息类似于：<br>请将下表的UUID、Major、Minor信息配置至iBeacon设备，其中，major、minor为10进制。</p><table><thead><tr><th>部署设备</th><th>设备ID</th><th>UUID</th><th>major值</th><th>minor值</th></tr></thead><tbody><tr><td>设备zero</td><td>3214551</td><td>FDA15795-A3E2-4FB1-DEWF-C6EB07154725</td><td>10100</td><td>44511</td></tr></tbody></table><p>1、2是前提条件，不满足API不会有任何反应<br>3 是后续会用到的参数，让PM弄好了给你，如果你自己就是PM就在公众号里找找，可以导出对应Excel</p><h2 id="获取beacon信息"><a href="#获取beacon信息" class="headerlink" title="获取beacon信息"></a>获取beacon信息</h2><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1443448133" target="_blank" rel="noopener">H5页面获取设备信息 JS API</a></p><p>微信提供了开启、监听、关闭三个Beacon对应的接口。<br>在开始查找之前还需要将设备添加至对应分组，否则<code>onSearchBeacons</code>不会有任何反应、不进入任何回调</p><h3 id="添加beacon至分组"><a href="#添加beacon至分组" class="headerlink" title="添加beacon至分组"></a>添加beacon至分组</h3><p>根据文档-(新增分组)[<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1459330208]" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1459330208]</a> </p><p>然后将步骤3中的设备加到分组中，<code>onSearchBeacons</code>只能监听位于分组中的beacon设备</p><h3 id="监听beacons"><a href="#监听beacons" class="headerlink" title="监听beacons"></a>监听beacons</h3><p>监听周边beacon前需要执行<code>startSearchBeacons</code>开启查找beacon</p><p>接着在成功回调中执行<code>onSearchBeacons</code>监听周围的beacon设备</p><h4 id="没反应的原因"><a href="#没反应的原因" class="headerlink" title="没反应的原因"></a>没反应的原因</h4><p>在开发过程中遇到的没有反应的原因有以下几种</p><ol><li>设备不在分组中</li><li>公众号没有添加设备</li><li>对应beacon设备没有绑定当前页面的URL</li><li>注册微信SDK的公众号和添加设备的公众号不一致</li></ol><h2 id="关闭beacon搜索"><a href="#关闭beacon搜索" class="headerlink" title="关闭beacon搜索"></a>关闭beacon搜索</h2><p>开启<code>startSearchBeacons</code>后，微信中关闭网页并不会自动stopSearchBeacons。<br>只能手动执行<code>stopSearchBeacons</code>关闭，可添加<code>beforeunload</code> listener在页面卸载前手动关闭</p>]]></content>
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信H5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS_7部署Nginx服务</title>
      <link href="/2018/06/03/CentOS-7%E9%83%A8%E7%BD%B2Nginx%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/06/03/CentOS-7%E9%83%A8%E7%BD%B2Nginx%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>没完整的建过站，于是把闲置的搬瓦工用起来。</p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>用终端连接VPS<br><code>ssh root@ip_address -p port</code><br>换成对应的ip地址和端口，输入正确密码后就成功连接。</p><p><code>yum install nginx</code> 安装nginx失败，提示：没有可用软件包 nginx</p><p>源里没有那就直接从官网下好了</p><p><code>rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></p><p>再安装就成功了。</p><h2 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h2><p><code>systemctl start nginx</code></p><p>如果启动成功就可以通过直接访问IP地址看到喜闻乐见的 <strong>Welcome to nginx!</strong></p><h2 id="OpenSSL生成CSR文件申请SSL证书"><a href="#OpenSSL生成CSR文件申请SSL证书" class="headerlink" title="OpenSSL生成CSR文件申请SSL证书"></a>OpenSSL生成CSR文件申请SSL证书</h2><p>DogDaddy上注册了一个<code>.app</code>的域名，还送了一年证书，也正好用起来。</p><p><code>openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout myprivate.key -out mydomain.csr</code></p><p>new: 生成一个新的CSR<br>nodes: 私钥文件不被加密<br>sha256: 摘要算法<br>keyout: 生成私钥,<br>newkey rsa:2048: 指定私钥类型和长<br>mydomain.csr: 最后生成的文件名</p><p>执行上面命令后会要求输入以下内容</p><table><thead><tr><th>内容</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Country Name</td><td>国家代码</td><td>CN</td></tr><tr><td>State or Province Name</td><td>省份</td><td>Beijing</td></tr><tr><td>Locality Name</td><td>城市</td><td>Beijing</td></tr><tr><td>Organization Name</td><td>组织名称</td><td></td></tr><tr><td>Organization Unit Name</td><td>部门名称</td><td>IT</td></tr><tr><td>Common Name</td><td>证书申请域名</td><td>example.app</td></tr><tr><td>A challenge password</td><td>某个密码</td><td>可不填</td></tr><tr><td>Email Address</td><td>邮件</td><td>我没填</td></tr></tbody></table><p>最后在命令所在目录会生成一个<code>myprivate.key</code> 和一个 <code>mydomain.csr</code>，分别为私钥和CSR申请文件。</p><p>🐶爹添加证书的时候就把CSR文件里的内容拷进去，申请一下就等着邮件通知签发证书。</p><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p><a href="https://www.secureserver.net/help/article/27192?prog_id=504762" target="_blank" rel="noopener">NGINX on CentOS 7: Install a Certificate</a></p><h3 id="通过scp拷贝文件至vps"><a href="#通过scp拷贝文件至vps" class="headerlink" title="通过scp拷贝文件至vps"></a>通过scp拷贝文件至vps</h3><p>基本格式为：scp -P [端口号] [源文件路径] root@ip_address:[目标路径]</p><p><strong>-P一定要大写！</strong> 默认端口可省略 -P [端口号]</p><h3 id="乌龙"><a href="#乌龙" class="headerlink" title="乌龙"></a>乌龙</h3><p>因为我注册了个<code>.app</code>后缀的域名，证书下载下来是<code>domain.app</code>被Mac识别成APP了，要显示包内容才能看到里面两个<code>.crt</code>文件。</p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@host /]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure><p><code>/etc/nginx/nginx.conf</code>就是配置文件所在的目录</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">            <span class="string">server_name</span> <span class="string">coolexample.com;</span></span><br><span class="line">            <span class="string">return</span> <span class="number">301</span> <span class="attr">https://$host$request_uri;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">443</span> <span class="string">ssl;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">server_name</span> <span class="string">coolexample.com;</span></span><br><span class="line">        <span class="string">ssl_certificate</span>     <span class="string">/etc/nginx/ssl/coolexample.crt;</span></span><br><span class="line">        <span class="string">ssl_certificate_key</span> <span class="string">/etc/nginx/ssl/coolexample.key;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">root</span> <span class="string">/usr/share/nginx/coolexample.com/;</span></span><br><span class="line">        <span class="string">index</span> <span class="string">index.php</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在配置文件中加入对应的配置~</p><p><code>root</code>是对应站点的跟目录，起初没写。导致使用https访问会404</p><p><code>sudo service nginx restart</code>重启服务后应该可以生效了，如果重启失败可以通过<code>nginx -t</code>检查配置文件是否有问题</p><p>愉悦~</p>]]></content>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Echarts动态加载GeoJSON地图</title>
      <link href="/2018/06/02/Echarts%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDGeoJSON/"/>
      <url>/2018/06/02/Echarts%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDGeoJSON/</url>
      <content type="html"><![CDATA[<h2 id="Echarts监听GEO地图缩放比例"><a href="#Echarts监听GEO地图缩放比例" class="headerlink" title="Echarts监听GEO地图缩放比例"></a>Echarts监听GEO地图缩放比例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myChart.on(<span class="string">'georoam'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  console.log(arguments);</span></span><br><span class="line">    <span class="comment">// 回调函数自带的res中zoom永远都是1.1</span></span><br><span class="line">    <span class="built_in">console</span>.log(myChart.getOption().geo[<span class="number">0</span>].zoom);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="按需加载GEOJSON"><a href="#按需加载GEOJSON" class="headerlink" title="按需加载GEOJSON"></a>按需加载GEOJSON</h2><p>某个需求要求的是点亮用户去过的地方，国内到城市、国外精确到州。</p><p>在Echarts官方仓库中找到<a href="https://github.com/pissang/starbucks" target="_blank" rel="noopener"><strong>starbucks</strong></a>，内含各个州的GEO数据。</p><p>直觉告诉我只要拼起来就能实现word数据中包含所有州的信息。</p><h3 id="GEOJSON"><a href="#GEOJSON" class="headerlink" title="GEOJSON"></a>GEOJSON</h3><p><a href="https://www.oschina.net/translate/geojson-spec?lang=chs&amp;page=1#" target="_blank" rel="noopener">格式规范说明</a></p><p><img src="https://i.loli.net/2018/05/30/5b0e443bb5e1e.png" alt="carbon.png"></p><p>大致就是这样一个结构、具体的键值含义规范中有说明。<code>features</code>数组中的每一个对象都描述的是<strong>一块区域</strong>。那么把<code>world.json</code>里缺失的更细颗粒度的区域也加进来就ojbk了。</p><h3 id="多余的key"><a href="#多余的key" class="headerlink" title="多余的key"></a>多余的key</h3><p>上面结构多了<code>UTF8Encoding</code> <code>encodeOffsets</code> <code>name</code> 这几个key，在格式规范中不是必须的，看了下<code>Echarts</code>处理JSON部分的源码是有用到的，用于decode JSON文件。</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>起初直接将两个JSON对象的<code>features</code>进行合并<code>world.features.concat(china.features)</code></p><p>失败了，合出来的JSON虽然符合规范，但是并不正确，渲染出来严重畸形。</p><p><img src="https://i.loli.net/2018/05/30/5b0e47c808ca9.png" alt="什么鬼(#`O′)"></p><p>经过对比，<code>world.json</code>中的<code>coordinates</code>字段为经纬度，<code>china.json</code>中则为Encode处理后的经纬度。</p><p>Debug源码发现由<code>UTF8Encoding</code>控制是否对JSON内容进行Decode，于是给合并后的JSON数据加上<code>UTF8Encoding = true</code>，然后又失败了。</p><p>控制台抛出异常：<code>Invalid geoJson format; coordinate.charCodeAt is not a function</code></p><p>喵喵喵??  decode完就格式就不对了…<br>Debug源码找到原因，<code>UTF8Encoding</code>为true开启decode后，对整个list进行decode操作，decode操作又要用到<code>encodeOffsets</code>，<code>world.json</code>没有这个key，所以就嗝屁了。</p><p>在拼接JSON前先把JSON给decode好，不就没问题了么，试了一下果然搞定了。</p><h3 id="看个效果"><a href="#看个效果" class="headerlink" title="看个效果"></a>看个效果</h3><p><img src="https://i.loli.net/2018/06/02/5b122a8887373.gif" alt="Jun-02-2018 13-25-09.gif"></p>]]></content>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
